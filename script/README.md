# Hotfix-Processing Scripts

## `grab_hotfixes.py`

This is the utility which is used to check for EGS+Steam hotfixes and
update this repo as-needed.  It currently runs at 10 after the hour via
cron, on a local box of mine.  It populates the main
`hotfixes_current.json` file in the main dir, and also an individual file
inside `point_in_time`.

It tries to do the right thing when EGS and Steam hotfixes diverge -- so
far, we've only seen that when the Steam hotfix updates lag behind the EGS
updates by some tens of minutes, though they seem to have more or less
straightened out their workflow for updating those, because we haven't seen
that in awhile now.  Currently the EGS hotfixes are considered the "main"
hotfixes, and Steam is compared against those.

`requirements.txt` lists the Python dependencies required to run this util.

## `convert_to_csv.py`

This is my script which pulls all the hotfix info from the main
`point_in_time` directory into a CSV/spreadsheet, which ends up
[living online at Google Sheets](https://drive.google.com/open?id=1kfkC2hJs0hZSr12bvrQlY0GyEH4S_KAI_xIAqnGmKnQ).

It also processes the file `fixup_hotfixes.txt`, which contains hotfixes
which have been pulled into the main game binary directly.  That text file
is generated by the Ghidra script `ghidra_bl3_fixups.py` (see below for
more info about that).  It contains all the hotfixes hardcoded into the
various `Fixup*` functions found hardcoded inside the BL3 main executable.

The `incorporated` column on the generated CSV means that a hotfix
previously found in one of our `point_in_time` files has been pulled in
directly to the binary, but the *absence* of an `incorporated` hit doesn't
mean that the hotfix's effects haven't been pulled in.  For instance, some
sniper rifle buffs were added in to a hotfix very early on in BL3's
lifecycle, and were pulled into the game binary in March 2020.  Unlike many
of the other incorporated hotfixes, though, they didn't just move it in
wholesale.  Rather, they had some code to go alter the related DataTable
entries directly.

## `grab_builtin_hotfixes.py`

Looks through the Mac BL3 Executable for widechar strings which look like
hotfixes, as an attempt to catalog all the hotfixes which have been hardcoded
straight into the game.  My `convert_to_csv.py` will then use that to try and
associate those to hotfixes which were previously being sent over the wire, so
we know which ones have been directly incorporated into the game binary.

As I mentioned before, the *absence* of a hotfix in this generated list
doesn't necessarily mean that a hotfix *hasn't* been pulled into the
binary.  Those sniper rifle buffs, for instance, were just done by GBX
via code, rather than hardcoding the hotfix itself.

Note that this is now the preferred method, instead of using the fancier
Ghidra script (below).  Ghidra turns out to have a hardcoded maximum string
length that it'll display, in decompilations, and we end up losing quite a
few hotfixes because of it.  This method is far more crude, and could
potentially be prone to false positives, but at the moment it's a better
solution.

## `ghidra_bl3_fixups.py`

**NOTE:** Ghidra turns out to have a maximum string length that it'll display
when doing decompilations, so this method ends up *losing* various hotfixes
(since the logic in here won't consider those to be hotfixes, thanks to how
they're formatted by Ghidra).  This method is fancy and is theoretically the
better way to go, if you're interested in pulling this information "correctly,"
but for now the more-crude method of `grab_builtin_hotfixes.py` is the way
to go.

A Ghidra script to loop through the BL3 executable and pull out hardcoded
hotfixes from the various `Fixup*` routines found in there.  This probably
only works on the Mac binary at the moment.  The process is entirely
automated, though you'll definitely have to at least tweak the output file
path near the top of the script.  Give it a run, and it'll loop through
and start with any function whose name starts with `Fixup`.  It's also got
some janky code to look for any other likely-looking fixup-related function
that gets called inside those, which don't actually have the `Fixup`
prefix.  (That's how it finds the `RebalanceGear` function, for instance.)

So it'll loop through all those functions and use Ghidra's decompilation
functionality to output a bunch of `.cpp` files.  It'll then loop through
all those files looking for some telltale hardcoded-hotfix strings, and
output 'em all to `fixup_hotfixes.txt`.  My `convert_to_csv.py` will then
use that to try and associate those to hotfixes which were previously
being sent over the wire, so we know which ones have been directly
incorporated into the game binary.

As I mentioned before, the *absence* of a hotfix in this generated list
doesn't necessarily mean that a hotfix *hasn't* been pulled into the
binary.  Those sniper rifle buffs, for instance, were just done by GBX
via code, rather than hardcoding the hotfix itself.

## `csv_investigate.py`

Just a bit of datamining that I was doing against hotfix sets, back when we
were still trying to figure out the new hotfix syntax.  I occasionally
break this out again when I want to do some aggregate data introspection.
